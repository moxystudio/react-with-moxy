#!/usr/bin/env node

require('dotenv').config();

const yargs = require('yargs');
const planify = require('planify');
const rimraf = require('rimraf');
const getPort = require('get-port');
const internalIp = require('internal-ip');
const express = require('express');
const opn = require('opn');
const pify = require('pify');
const webpackIsomorphicCompiler = require('webpack-isomorphic-compiler');
const webpackIsomorphicDevMiddleware = require('webpack-isomorphic-dev-middleware');
const webpackHotMiddleware = require('webpack-hot-middleware');
const { getConfig: getWebpackConfig } = require('./config/webpack');
const { build: buildManifest } = require('./util/manifest');
const { publicDir } = require('./util/constants');

// ---------------------------------------------------------
// CLI definition
// ---------------------------------------------------------

const argv = yargs
.strict()
.wrap(Math.min(120, yargs.terminalWidth()))
.help()
.alias('help', 'h')
.version()
.alias('version', 'v')
.usage('Usage: ./$0 [options]')
.option('host', {
    alias: 'H',
    type: 'string',
    default: process.env.HOST || process.env.HOSTNAME || '0.0.0.0',
    describe: 'The host to bind to',
})
.option('port', {
    alias: 'p',
    type: 'number',
    default: Number(process.env.PORT) || 3000,
    describe: 'The port to bind to',
})
.option('poll', {
    type: 'boolean',
    default: process.env.WEBPACK_DEV_POOL === '1',
    describe: 'Use polling when watching for file changes, disable it if you are having issues with polling (defaults to automatic)',
})
.option('memory-fs', {
    type: 'boolean',
    default: process.env.WEBPACK_DEV_MEMORY_FS !== '0',
    describe: 'Use an in-memory filesystem instead of writing assets to disk (recommended)',
})
.option('reporter', {
    type: 'string',
    describe: 'Any of the planify\'s reporters',
})
.example('$0', 'Serves the application for local development')
.example('$0 --port 8081', 'Serves the application for local development on port 8081')
.example('$0 --no-memory-fs', 'Write files in disk instead of in memory ')
.argv;

// ---------------------------------------------------------
// Functions
// ---------------------------------------------------------

function createIsomorphicCompiler() {
    // Build webpack configs
    const clientConfig = getWebpackConfig('client');
    const serverConfig = getWebpackConfig('server');

    // Create the isomorphic compiler
    return webpackIsomorphicCompiler(clientConfig, serverConfig);
}

// ---------------------------------------------------------
// Steps
// ---------------------------------------------------------

function prepare(data) {
    // Force ENV to development
    process.env.NODE_ENV = 'development';

    // Remove previous build
    rimraf.sync(`${publicDir}/build`);
    process.stdout.write('Previous build removed successfully.\n');

    // Create isomorphic compiler
    data.isomorphicCompiler = createIsomorphicCompiler(argv);
}

async function findFreePort() {
    const port = await getPort({ host: argv.host, port: argv.port });

    if (port !== argv.port) {
        process.stdout.write(`Port ${argv.port} is already in use, using ${port} instead..\n`);
        argv.port = port;
    } else {
        process.stdout.write(`Port ${argv.port} is free.\n`);
    }
}

async function runServer(data) {
    const { host, port, poll, memoryFs } = argv;
    const { isomorphicCompiler } = data;
    const app = express();

    // Configure express app
    app.set('etag', false);  // Not necessary by default

    // Public files in /build are served without any cache
    // (this isn't necessary unless memoryFs is disabled in the `webpack-isomorphic-dev-middleware`)
    app.use('/build', express.static(`${publicDir}/build`, {
        index: false,
        etag: false,
    }));

    // The rest of the public files are served using a more modest approach using etags
    app.use(express.static(publicDir, {
        index: false,
    }));

    // If it's not a public file, render the app!
    app.use(
        // Setup compilaton so that changes are compiled on the fly!
        webpackIsomorphicDevMiddleware(isomorphicCompiler, {
            memoryFs,
            watchDelay: 50,
            watchOptions: { poll },
            // OS notifications! (skip if CI)
            notify: { icon: !process.env.CI ? `${publicDir}/favicon.ico` : undefined },
        }),
        webpackHotMiddleware(isomorphicCompiler.client.webpackCompiler, {
            log: false,
        }),
        (req, res, next) => {
            const { locals } = res;

            locals.exports = locals.isomorphicCompilation.exports;
            locals.buildManifest = locals.buildManifest || buildManifest(locals.isomorphicCompilation.stats);
            next();
        },
        // Call `render()` from the server bundle
        (req, res, next) => {
            const { exports, buildManifest } = res.locals;

            Promise.resolve(exports.render({ req, res, buildManifest }))
            .catch(next);
        },
        // Call `renderError()` on errors
        (err, req, res, next) => {
            const { exports, buildManifest } = res.locals;

            // Skip if there's no defined `renderError` or if we don't have any exports, e.g.: compilation failed
            if (!exports || !exports.renderError) {
                return next(err);
            }

            Promise.resolve(exports.renderError({ err, req, res, buildManifest }))
            .catch(next);
        }
    );

    // Start server
    await pify(app.listen).call(app, port, host);

    const url = `http://${host === '0.0.0.0' ? '127.0.0.1' : host}:${port}`;
    const lanUrl = `http://${await internalIp.v4()}:${port}`;

    process.stdout.write(`Server address:            ${url}\n`);
    process.stdout.write(`LAN server address:        ${lanUrl}\n`);
    process.stdout.write('Hot module replacement:    on\n');
    process.stdout.write('\nServer is now up and running, press CTRL-C to stop.\n');

    // Open app in the browser (skip if doing CI)
    !process.env.CI && opn(url, { wait: false }).catch(() => {});
}

// ---------------------------------------------------------
// Steps
// ---------------------------------------------------------

planify({ reporter: argv.reporter })
.step('Preparing', (data) => prepare(data))
.step('Finding free port', () => findFreePort())
.step('Running server', (data) => runServer(data))
.run()
.catch((err) => process.exit(err.exitCode || 1))
// Print a new line after planify ends to separate from the subsequent compilations
.then(() => process.stdout.write('\n'));
